---
title: 'View Transitions API と Navigation API を用いて非同期遷移アニーションを実装してみる'
emoji: '📚'
type: 'tech' # tech: 技術記事 / idea: アイデア
topics: ['HTML', 'CSS', 'JavaScript']
published: false
---

Chrome 102 以降で **Navigation API** が、Chrome 111 以降で **View Transitions API** がサポートされました。 本記事では、この二つの API を用いた非同期遷移アニメーションを実装してみます。

:::message
この記事が執筆された 2023 年 8 月 12 日現在では、View Transitions API と Navigation API はまだ限られたブラウザ・範囲でしかサポートされていません。これらを使用する際には、「[Can I use... Support tables for HTML5, CSS3, etc](https://caniuse.com/)」といったリソースを参照することをおすすめします。
:::
https://caniuse.com/mdn-api_navigation
https://caniuse.com/view-transitions

## デモサイト&コード

https://vta-and-na.yend.dev/
https://github.com/yend724/view-transitions-api-and-navigation-api-demo

本記事では上記のデモサイトとコードをもとに説明を行うことがあります。全体的な挙動やコードを確認したい際は、上記をご参照ください。

## View Transitions API

View Transitions API を用いると、異なる DOM 状態間でのアニメーションを簡単に行うことができます。

### デモページ&コード

https://vta-and-na.yend.dev/view-transitions-api/
https://github.com/yend724/view-transitions-api-and-navigation-api-demo/tree/main/src/view-transitions-api

### View Transitions API を用いたアニメーション

```js
const swap = async ([to, from]) => {
  return document.startViewTransition(() => {
    from.hidden = true;
    to.hidden = false;
  }).updateCallbackDone;
};

const findAnchorElement = element => {
  if (element.tagName === 'A') {
    return element;
  }
  return null;
};
const findParentAnchorElement = element => {
  return element.closest('a');
};

const bookIndexPage = document.querySelector(
  '*[data-transition-wrapper="book-index"]'
);
const bookDetailPage = document.querySelector(
  '*[data-transition-wrapper="book-detail"]'
);
const pageList = [bookIndexPage, bookDetailPage];

const documentBody = document.body;
documentBody.addEventListener('click', async e => {
  const target = e.target;
  const anchorElement =
    findAnchorElement(target) || findParentAnchorElement(target);
  if (anchorElement) {
    e.preventDefault();
    const url = new URL(anchorElement.href);
    const params = url.searchParams;
    const nextPage = params.get('page') ?? 'book-index';
    const nextSwapList =
      nextPage === 'book-index' ? pageList : [...pageList].reverse();
    await swap(nextSwapList);
  }
});
```

## Navigation API

Navigation API は、ページ遷移やナビゲーションのハンドリングを行うための API です。

### デモページ&コード

https://vta-and-na.yend.dev/navigation-api/
https://github.com/yend724/view-transitions-api-and-navigation-api-demo/tree/main/src/navigation-api

### Navigation API を用いたナビゲーションのハンドリング

```js
const parser = new DOMParser();
const parseHTML = html => {
  return parser.parseFromString(html, 'text/html');
};
const getHTML = async url => {
  return fetch(url).then(res => res.text());
};
const swap = (from, to) => {
  from.replaceWith(to);
};

const shouldNotIntercept = navigationEvent => {
  // 参考: https://developer.chrome.com/docs/web-platform/navigation-api/#deciding-how-to-handle-a-navigation
  return (
    !navigationEvent.canIntercept ||
    navigationEvent.hashChange ||
    navigationEvent.downloadRequest ||
    navigationEvent.formData
  );
};
navigation.addEventListener('navigate', e => {
  if (shouldNotIntercept(e)) return;

  const loadNextPage = async () => {
    const htmlString = await getHTML(e.destination.url);
    const parsedHTML = parseHTML(htmlString);
    const toHTML = parsedHTML.querySelector('*[data-transition-wrapper]');
    const fromHTML = document.querySelector('*[data-transition-wrapper]');
    swap(fromHTML, toHTML);
    document.title = parsedHTML.title;
  };
  e.intercept({ handler: loadNextPage });
});
navigation.addEventListener('navigatesuccess', e => {
  console.log(e);
});
navigation.addEventListener('navigateerror', e => {
  console.error(e);
});
```

## View Transitions API と Navigation API を用いた非同期遷移アニメーションの実装

それでは、View Transitions API と Navigation API を組み合わせて非同期遷移アニメーションを実装する方法を見てみましょう。

### デモページ&コード

https://vta-and-na.yend.dev/async-transition-animation/
https://github.com/yend724/view-transitions-api-and-navigation-api-demo/tree/main/src/async-transition-animation

```js
const parser = new DOMParser();
const parseHTML = html => {
  return parser.parseFromString(html, 'text/html');
};
const getHTML = async url => {
  return fetch(url).then(res => res.text());
};
const swap = ([from, to]) => {
  return document.startViewTransition(() => {
    from.replaceWith(to);
  }).updateCallbackDone;
};

const shouldNotIntercept = navigationEvent => {
  // 参考: https://developer.chrome.com/docs/web-platform/navigation-api/#deciding-how-to-handle-a-navigation
  return (
    !navigationEvent.canIntercept ||
    navigationEvent.hashChange ||
    navigationEvent.downloadRequest ||
    navigationEvent.formData
  );
};
navigation.addEventListener('navigate', e => {
  if (shouldNotIntercept(e)) return;

  const loadNextPage = async () => {
    const htmlString = await getHTML(e.destination.url);
    const parsedHTML = parseHTML(htmlString);
    const toHTML = parsedHTML.querySelector('*[data-transition-wrapper]');
    const fromHTML = document.querySelector('*[data-transition-wrapper]');
    await swap([fromHTML, toHTML]);
    document.title = parsedHTML.title;
  };
  e.intercept({ handler: loadNextPage });
});
navigation.addEventListener('navigatesuccess', e => {
  console.log(e);
});
navigation.addEventListener('navigateerror', e => {
  console.error(e);
});
```

## 終わりに

この記事では、View Transitions API と Navigation API を活用した非同期遷移アニメーションの基本的な実装方法について紹介しました。
実は [Cross Document View Transitions](https://github.com/WICG/view-transitions/blob/main/cross-doc-explainer.md) なるものも策定中？らしいので、将来的には本記事で紹介した方法よりも、さらに簡易な方法でアニメーション付き非同期遷移が実現できるようになるかもしれませんね。引き続きキャッチアップしていきたいと思います。


## 参考

https://drafts.csswg.org/css-view-transitions/
https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API
https://ics.media/entry/230510/
https://html.spec.whatwg.org/multipage/nav-history-apis.html#navigation-api
https://developer.mozilla.org/en-US/docs/Web/API/Navigation_API
https://blog.jxck.io/entries/2022-04-22/navigation-api.html
